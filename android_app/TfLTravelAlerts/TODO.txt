Work list:
==========

doing:

ordered:
  - work with architecture
    - do more Rx
      - expose a method that listens to network status/configured alarms that emits incremental changes
      - make state machine more rx ?
      - allow state machine to expose events
      - allow state machine listeners to further emit more events?
  - each contract should implement a reducer instead of extending a state machine
  - review MVI architecture and alternatives
      - check TODOs
      - alarm detail is odd..
          - make state private in state machine
          - handle disposable in alarm detail presenter
          - alarm detail has a presenter which is different from the others
  - introduce view models to avoid passing time printer into data binding
  - add delete icon to alarm detail

unordered:
  - use live data et. al.
  - think about good approach using view model, live data, repositories/data stores
  - remove kapt (includes remove use of paper parcel) - start using annotationProcessor
  - because of using data binding, in the alarms page of main activity, when the user changes the
    enabled/disabled state of an alarm, I need to delay the save callback respond so the switch
    ends the animation that reflects the user input. This sucks. See related TODOs in
    AlarmsPageStateMachine and AlarmsPageInteractions
  - make a network status store automatically fetches the first data when the first observer subscribes
  - make a network status store that keeps data in memory + shared prefs


New Architecture:
=================

There are two possible approaches for how the view publishes its' activity:
  - The view defines a sealed class with all UI actions that can happen and then the presenter (or
    something else?) has to have a method that receives those events, computes new state, and
    updates the view
    = ui event class similar to UiEvent but with sealed class instead
    + it still doesn't guarantee that the receiver will handle all possible events, but thanks to
      kotlin's exhaustive `when`, it will be unlikely we miss something
    + subscription details remain private to the view
    - the view has to be a bit smarter although not terribly smarter
    ? which one is best for composition? (having sub-presenters)
    ? which one is best reuse? (other activities/fragments/views using this)

  - The view exposes a few methods with publish each event (observer chain) and the presenter
    (or something else?) subscribes all events, computes new state, and updates the view
    = similar to ViewActions
    - there is no type safety. nothing guarantees the presenter is listening to all events
    - if a separate presenter wants to use this, it would need to repeat the logic of the presenter
      (...) but how likely is that to ever happen?
    ? which is one best for composition?
    ? which one is best reuse? (other activities/fragments/views using this)

GENERAL:
========
- I don't like that there are three different objects for ConfiguredAlarms: the data class, the
  entity and the "UI" class that is mutable (and has more fields)
- I can call @WorkerThread annotated methods from the UI thread without lint warnings
- send network errors to the subscribers
- I would like to avoid using reflection to parse json. perhaps could use Some library that creates
  the json parser at compile time?
- user kotlin extensions for parceler
- should the state reduced be an interface or an abstract class

Main/Initial Screen:
====================
- The code is a mess. Rewrite it in someway that looks better
- When the data changes in the adapters, it would be nice to refresh if the toolbar should collapse.
The easy case to spot an error is if a page is opened while the data is being downloaded (and there is
no cached data), when the data arrives if you scroll, the toolbar won't collapse as it ideally would.


Alert details using MVI:
========================

- [done] implement time selection
    - could try to "connect" the click event on time view to showing the fragment with a rx stream
- add a delete icon to the toolbar
    - maybe a delete button too
- the clock icon set as startDrawable will CRASH older android version
- handle tearing down the rx streams (activity on pause/stop/destroy)

ALERT DETAIL:
=============

- implement save/restore state



MUST DO BEFORE RELEASE:
=======================
- layout in older android versions looks wrong
    - not getting compat version of switch view
    - spacing is wrong
- migrate alarms from previous version
- implement push notifications
- integrate crashlytics


COULD DO:
=========
- option to be always up to date with the line status
- double check order of lines
- in the network status scrollingViews, collapse lines with good status

DREAMS:
=======

- maybe could write a library similar to RxBindings using co-routines
- replace rx with co-routines
