Work list:
==========

ordered:
  - rotation the screen on alarm details crashes the app
  - when I open the time picker dialog in alarm details screen, I need to press back one extra time
  - work with architecture
    - do more Rx
      - allow state machine listeners to further emit more events?
      - review the interactions use in the factories... looks a bit strange

  - review MVI architecture and alternatives
      - check TODOs

unordered:
  - it looks like there are two classes of intents: mutation and actions.
      - mutation is something like ticking a checkbox. the state reducer is able to generate a new
        state and can show it immediately.
      - actions (interactions?) is things that involve going to the server to do something or
        updating the database, dismissing a dialog that is shown to the user. Conceptually, the
        state shown to the user doesn't change at least immediately (it will probably change when
        that action is completed as it probably reflects with some change back in the UI)

      - what about an button clicks to do a server call?

      ... study an approach where we distinguish mutation events; can an event be both? (probably)
  - expose a method that listens to network status/configured alarms that emits incremental changes
  - maybe the state machine should be injected instead of manually created.
    I tried doing this but because of type erasure, we can't use DI to inject different state
    machines unless we name each one of them. At this point I don't feel like I need to inject the
    state machine but it might be useful for unit testing in the future
  - use live data et. al.
  - think about good approach using view model, live data, repositories/data stores
  - remove kapt (includes remove use of paper parcel) - start using annotationProcessor
  - because of using data binding, in the alarms page of main activity, when the user changes the
    enabled/disabled state of an alarm, I need to delay the save callback respond so the switch
    ends the animation that reflects the user input. This sucks. See related TODOs in
    AlarmsPageStateMachine and AlarmsPageInteractions
  - make a network status store automatically fetches the first data when the first observer subscribes
  - make a network status store that keeps data in memory + shared prefs
  - experiment view state restoration
  - introduce view models to avoid passing time printer into data binding
  - add delete icon to alarm detail
  - unit tests
  - ui tests
  - in alarm detail view, when the snackbar is shown, it will overlap the the scrollview behind.
    Need to implement a custom coordinator layout behaviour (?!!)
  - see if I can make something with koin that I saw get [stateMachine of type]<Intent> (initialData)
    and automatically solves the reducer inside
    e.g. get(parametersOf(initialData, AlarmPageContract.Intent)) returns the appropriate state
    machine with corresponding reducer

    alternative: get<StateMachine<xyzData, AlarmPageContract.Intent> (parametersOf(initialData))

  - test having the data stores expose loading data events
    - I'm not sure this is the best thing though. For example, in the scenario where we want to load
      data and use a disk cache and still go to the network, the store could only indicate loading
      while loading from disk; but then there would be no indication that there is more things happening
      in the bg

      alternative 1: unless we directly make that a concern of the store. In this case it could emit
      something on top of the data exposing it self. E.g. (loading: yes, data: x)

      alternative 2: or simply assuming that if the rx stream hasn't completed, there are things
      going on
        - not a fan because some usages of rx imply that the subscriptions are never ending


New Architecture:
=================

There are two possible approaches for how the view publishes its' activity:
  - The view defines a sealed class with all UI actions that can happen and then the presenter (or
    something else?) has to have a method that receives those events, computes new state, and
    updates the view
    = ui event class similar to UiEvent but with sealed class instead
    + it still doesn't guarantee that the receiver will handle all possible events, but thanks to
      kotlin's exhaustive `when`, it will be unlikely we miss something
    + subscription details remain private to the view
    - the view has to be a bit smarter although not terribly smarter
    ? which one is best for composition? (having sub-presenters)
    ? which one is best reuse? (other activities/fragments/views using this)

  - The view exposes a few methods with publish each event (observer chain) and the presenter
    (or something else?) subscribes all events, computes new state, and updates the view
    = similar to ViewActions
    - there is no type safety. nothing guarantees the presenter is listening to all events
    - if a separate presenter wants to use this, it would need to repeat the logic of the presenter
      (...) but how likely is that to ever happen?
    ? which is one best for composition?
    ? which one is best reuse? (other activities/fragments/views using this)

GENERAL:
========
- I don't like that there are three different objects for ConfiguredAlarms: the data class, the
  entity and the "UI" class that is mutable (and has more fields)
- I can call @WorkerThread annotated methods from the UI thread without lint warnings
- send network errors to the subscribers
- I would like to avoid using reflection to parse json. perhaps could use Some library that creates
  the json parser at compile time?
- user kotlin extensions for parceler
- should the state reduced be an interface or an abstract class

Main/Initial Screen:
====================
- When the data changes in the adapters, it would be nice to refresh if the toolbar should collapse.
The easy case to spot an error is if a page is opened while the data is being downloaded (and there is
no cached data), when the data arrives if you scroll, the toolbar won't collapse as it ideally would.


Alert details using MVI:
========================

- add a delete icon to the toolbar
    - maybe a delete button too
- the clock icon set as startDrawable will CRASH older android version
- handle tearing down the rx streams (activity on pause/stop/destroy)

ALERT DETAIL:
=============

- implement save/restore state
- implement validation / showing error message (couldn't save because of required data)


MUST DO BEFORE RELEASE:
=======================
- layout in older android versions looks wrong
    - not getting compat version of switch view
    - spacing is wrong
- migrate alarms from previous version
- implement push notifications
- integrate crashlytics


COULD DO:
=========
- option to be always up to date with the line status
- double check order of lines
- in the network status scrollingViews, collapse lines with good status

DREAMS:
=======

- maybe could write a library similar to RxBindings using co-routines
- replace rx with co-routines
