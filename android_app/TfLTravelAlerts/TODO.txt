Work list:
==========

doing:

ordered:
  - work with architecture
    - do more Rx
      - allow state machine listeners to further emit more events?
      - review the interactions use in the factories... looks a bit strange

  - BUG opening the time picker crashes when I try to do it on a second activity; also the back
    stack handling is borken
  - review MVI architecture and alternatives
      - check TODOs
      - alarm detail is odd..
          - handle disposable in alarm detail presenter
          - alarm detail has a presenter which is different from the others
          - the presenter has chicken and egg problems with getting a state machine but the initial
            data being provided only later


unordered:
  - expose a method that listens to network status/configured alarms that emits incremental changes
  - maybe the state machine should be injected instead of manually created.
    I tried doing this but because of type erasure, we can't use DI to inject different state
    machines unless we name each one of them. At this point I don't feel like I need to inject the
    state machine but it migth be useful for unit testing in the future
  - it seems that the initial state in the state machine is not propagated to the view
    (at least in the main screen, if it take a long time to get the network response, we don't see
    loading)
  - use live data et. al.
  - think about good approach using view model, live data, repositories/data stores
  - remove kapt (includes remove use of paper parcel) - start using annotationProcessor
  - because of using data binding, in the alarms page of main activity, when the user changes the
    enabled/disabled state of an alarm, I need to delay the save callback respond so the switch
    ends the animation that reflects the user input. This sucks. See related TODOs in
    AlarmsPageStateMachine and AlarmsPageInteractions
  - make a network status store automatically fetches the first data when the first observer subscribes
  - make a network status store that keeps data in memory + shared prefs
  - experiment view state restoration
  - introduce view models to avoid passing time printer into data binding
  - add delete icon to alarm detail
  - unit tests
  - see if I can make something with koin that I saw get [stateMachine of type]<Intent> (initialData)
    and automatically solves the reducer inside
    e.g. get(parametersOf(initialData, AlarmPageContract.Intent)) returns the appropriate state
    machine with corresponding reducer

    alternative: get<StateMachine<xyzData, AlarmPageContract.Intent> (parametersOf(initialData))

  - test having the data stores expose loading data events
    - I'm not sure this is the best thing though. For example, in the scenario where we want to load
      data and use a disk cache and still go to the network, the store could only indicate loading
      while loading from disk; but then there would be no indication that there is more things happening
      in the bg

      alternative 1: unless we directly make that a concern of the store. In this case it could emit
      something on top of the data exposing it self. E.g. (loading: yes, data: x)

      alternative 2: or simply assuming that if the rx stream hasn't completed, there are things
      going on
        - not a fan because some usages of rx imply that the subscriptions are never ending


New Architecture:
=================

There are two possible approaches for how the view publishes its' activity:
  - The view defines a sealed class with all UI actions that can happen and then the presenter (or
    something else?) has to have a method that receives those events, computes new state, and
    updates the view
    = ui event class similar to UiEvent but with sealed class instead
    + it still doesn't guarantee that the receiver will handle all possible events, but thanks to
      kotlin's exhaustive `when`, it will be unlikely we miss something
    + subscription details remain private to the view
    - the view has to be a bit smarter although not terribly smarter
    ? which one is best for composition? (having sub-presenters)
    ? which one is best reuse? (other activities/fragments/views using this)

  - The view exposes a few methods with publish each event (observer chain) and the presenter
    (or something else?) subscribes all events, computes new state, and updates the view
    = similar to ViewActions
    - there is no type safety. nothing guarantees the presenter is listening to all events
    - if a separate presenter wants to use this, it would need to repeat the logic of the presenter
      (...) but how likely is that to ever happen?
    ? which is one best for composition?
    ? which one is best reuse? (other activities/fragments/views using this)

GENERAL:
========
- I don't like that there are three different objects for ConfiguredAlarms: the data class, the
  entity and the "UI" class that is mutable (and has more fields)
- I can call @WorkerThread annotated methods from the UI thread without lint warnings
- send network errors to the subscribers
- I would like to avoid using reflection to parse json. perhaps could use Some library that creates
  the json parser at compile time?
- user kotlin extensions for parceler
- should the state reduced be an interface or an abstract class

Main/Initial Screen:
====================
- When the data changes in the adapters, it would be nice to refresh if the toolbar should collapse.
The easy case to spot an error is if a page is opened while the data is being downloaded (and there is
no cached data), when the data arrives if you scroll, the toolbar won't collapse as it ideally would.


Alert details using MVI:
========================

- [done] implement time selection
    - could try to "connect" the click event on time view to showing the fragment with a rx stream
- add a delete icon to the toolbar
    - maybe a delete button too
- the clock icon set as startDrawable will CRASH older android version
- handle tearing down the rx streams (activity on pause/stop/destroy)

ALERT DETAIL:
=============

- implement save/restore state



MUST DO BEFORE RELEASE:
=======================
- layout in older android versions looks wrong
    - not getting compat version of switch view
    - spacing is wrong
- migrate alarms from previous version
- implement push notifications
- integrate crashlytics


COULD DO:
=========
- option to be always up to date with the line status
- double check order of lines
- in the network status scrollingViews, collapse lines with good status

DREAMS:
=======

- maybe could write a library similar to RxBindings using co-routines
- replace rx with co-routines
